# Data structures
The program implements 5 structures, a sorted and an unsorted array, a hash table, a binary search tree and an AVL binary search tree. The unsorted array consists of 1 simple constructor, 1 simple destructor and 4 functions. The main function is insert(string), which accepts a string as an argument and inserts it into the array. If the initial space of the array is not enough, then it calls the resize() function, which each time allocates twice as much space for the needs of the program. The find(string) and search(string) functions accept a string as an argument and return the position of the string in the array and how many times it is in the array, respectively. The sorted array is similar to the unsorted array, but has the difference that when inserting each string it inserts it in the correct position using the helper function findPosition(string) sorting the array as it is created. Also, binary search is used as the array is sorted. In the hash array there are 2 basic operations that are implemented: Inserting a string into the array and searching for it. These functions are insert(char* w) and search(char* w), which are achieved with the help of the hash function. Specifically, the quadratic search method is used to examine the array. The binary search tree (BST) consists of recursive functions, with which strings are inserted (insert(char* w)), deleted (deletion(char* w)) and searched (search(char* w)). The insert function compares the string with the first string that has been inserted and recursively directs it to its correct position. The search is done in a similar way. The deletion is done by examining the left and right subtrees, performing the deletion and replacing the original string with it. In the case that there is a subtree from both directions, we replace it with the minimum node of the right subtree. The AVL binary search tree has similar functions, but since it must be balanced and have height < 2 it has 4 helper functions. LeftRotation() and RightRotation() are used to move the tree to the left andright respectively, adjusting it appropriately to balance it. newBalance() and newHeight() are called when changes are made to the tree and calculate the balance of thetree and its height respectively.

Main function:
Before the main function starts, a helper function is implemented, bool removeChars(char* str) which is used to remove punctuation marks and convert all uppercase characters to lowercase, from a string str. After processing the string, it returns a logical result, so that the main function does not insert an empty string into the structures. Starting, the program opens a folder (in this case the folder “small-file.txt”) and if it has been opened normally, then it constructs the empty structures. Then, it opens the folder “output.txt” in order to print the necessary data there and initializes the necessary variables. Then it starts to read 1 word from the text file iteratively (In the first iteration it reads 2) and merges the word it read with the previous one. Then, it calls the function removeChars(char* str) to process the string and insert it into the structures, measuring the insertion time. Also, the random set of strings Q is constructed, from which the searches will be made. Before completing the iteration, it stores the second word for use in the next iteration. Following the completion of the insertion, the program searches each member of the set Q and records the search times, before writing them to the file output.txt

Results:
From the final construction and search times, we conclude that the unsorted array is the least efficient structure, as it takes the most time both in its construction and in the search. When it is sorted, both processes are reduced by half the time and more. The times between the two trees are similar in terms of search, but the construction of the AVL tree takes longer due to the multiple moves. Finally, the hash table takes longer to construct than the sorted table and both trees, but has the best search time.
